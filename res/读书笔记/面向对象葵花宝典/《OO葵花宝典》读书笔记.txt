《OO葵花宝典》读书笔记

完成任务后, 您可以点击图标, 修改为已完成.

面向对象基础

面向对象概述

史前时代:面向机器

面向过程

面向过程是一种以“过程”作为中心的编程思想,其中过程的含义就是“完成一件事情的步骤”

面向过程其实是一种“机械的思想”,它就像流水线一样,一个阶段衔接一个阶段,每个阶段都有自己的输入、处理、输出,而在流水线上流动的就是我们的原料或者中间产品,每个阶段都有一个机械进行处理,最后的输出就是我们的产品

在运用面向过程的方法时,你也需要设计这样一条程序流水线:将程序划分为不同的阶段,设计好各个阶段如何衔接,然后定义好每个阶段需要处理的数据。

面向对象

与面向过程的方法相比,面向对象不再局限于计算机的机器本质,而更加侧重于对现实世界的模拟。

面向对象这种对现实世界的模拟的思想,其本质上就是“人的思想”,这是一个质的飞跃,意味着程序员可以按照人的思想来观察、分析、设计系统。

如果说面向过程像一条流水生产线,那么面向对象就像是一个足球队。没有哪个人能够在一场比赛开始的时候,就精确指定每个队员的每一次跑动,每一次出脚,每一次传球。。。
而只能指定队员的角色(前锋、中场、后卫、门将),然后由队员门自己根据情况做出反应。所以世界上有两个一样的生产线,但绝对不会存在两场一模一样的比赛。

面向过程中有“程序=算法+数据结构”的经典总结,面向对象也有类似的总结:
“程序=对象 + 交互”。

面向过程有流水线的这个缺点,即:流程和原料相对固定,扩展比较麻烦。而面向对象正是为了解决面向过程的这个缺点儿诞生的,因此面向对象其实也不是什么复杂和玄妙的技
术,面向对象思想的核心是“可扩展性”!

既然面向对象思想的核心是“可扩展性”,那么其适用范围就显而易见了:经常变化的地方就是面向对象应用的地方。

软件属性全图



可以看到,“可扩展性”只是软件质量属性中很小的一部分,其它的属性都不是面向对象能够解决的。明白了面向对象的特点和适用范围,是应用面向对象的关键,经过前面的分析,我们知道,面向对象不是瑞士军刀,而只是一个普通的锤子而已,千万不要拿着锤子到处敲!

面向对象会导致性能降低?

从数据我们可以看出,如果你的业务流程中涉及了磁盘、网络、数据库等操作,那么性能就一下子降到了毫秒级。

因此,对于复杂的业务系统来说,性能的好坏是由设计来决定的,而不是由语言来决定的,更不会因为采用了面向对象而导致性能的降低!

面向对象理论

类

类就是一组相似事物的统称。

“如何定义类“? “只要有相似点的就是同一类“!

角度决定看法! 如何划分类:站在你的观察角度,具有相似点的事物就是同一类!

名词是属性,动词是方法。

设计属性的一个基本原则:属性最小化原则,即: “属性不可再分”!

设计方法的一个基本原则:方法单一化原则,即:一个方法只做一件事!

对象

类的实例。

现实对象-> 归纳概括-> 现实类-> 抽象模拟-> 软件类-> 实例化-> 软件对象-> 活动交互-> 程序

“软件类来源于现实类,但高于现实类”:
现实类在软件类中必须有对应,但并不是完全一 一对应的
软件类并不一定是现实存在的

接口

“接口”是我见过的面向对象领域中滥用、乱用、误用最多的术语

接口是一组相关的交互功能点定义的集合。

抽象类

抽象类是一种特殊的类,其特殊性在于抽象类只能用于继承,不能被实例化

抽象类和接口有什么区别,为什么有了接口,还要有抽象类?
抽象类本质上还是类,强调一组事物的相似性,包括属性和方法的相似性;而接口只强调方
法的相似性,并且仅仅体现在方法声明上的相似性,而没有方法定义上的相似性。
(代码复用)

抽象

“抽取出来比较像的部分”

抽象的详细含义:抽取多个对象或者类中比较像的部分。

“属性类似”

“行为类似”

抽象的作用: 抽象最主要的作用是“划分类别”,而划分类别的主要目的其实还是“隔离关注点,降低复杂度”。因为这个世界太复杂了,复杂到一个人不可能同时关注所有的内容。心理学上的研究证实,人同时能关注的事务不超过 7+/-2 个。可以想象,如果没有抽象分类,我们将面对一个混沌的世界,同时关注如此多的内容,即使是天才,估计也要崩溃。

三大核心特征

封装

“保护隐私”

“隔离复杂度”

继承

继承类似生物学上的“遗传”，“龙生龙,凤生凤,老鼠生来会打洞”

面向对象的继承意味“子类”遗传了了某些“父类”的属性和方法。

抽象:是分析和设计过程中的一个动作,一个技巧,通过抽象得出类

继承:是实现过程中的一个动作,基于抽象结果,通过编程语言的特性,完成抽象图的模拟。

多态

“多胎”，多态的形态再多也只能局限在子类的个数，即父类的“胎”数

多态的特性在面向对象编程的领域中具有十分重要的作用。多态屏蔽了子类对象的差异,
使得调用者可以写出通用性的代码,而无需针对每个子类都需要写不同的代码。

面向对象实战

对象全流程概述

我们将瀑布模型、敏捷开发等称为“管理流程”

将面向对象开发流程称为“技术流程”

面向对象的技术流程可以概括如下: 需求模型 -> 领域模型 -> 设计模型 -> 实现模型

通过这种一步一个脚印的方式,即使是经验并不丰富的菜鸟,也能完成从需求到最后实现的相关工作,而不再需要仰望和崇拜其他大虾大牛,或者自己摸着石头过河了!

需求模型

通过和客户沟通,结合行业经验和知识,明确要求客户的需求。

领域模型

基于需求模型,提炼出领域相关的概念,为后面的面向对象设计打下基础。

设计模型

以领域模型为基础,综合面向对象的各种设计技巧,完成类的设计。

实现模型

以设计模型为基础,将设计模型翻译为具体的语言实现,完成编码。

需求模型

需求详解

需求即系统需要做什么

正是这个简单的定义,让很多人陷入了陷阱:需求即功能。

需求:对客户来说有价值的事情;

功能:系统为了实现客户价值而提供的能力;

区别是需求还是功能的方法很简单了:只要判断是否对客户有价值。

需求的重要性

很多项目都不怎么重视需求!

据统计,有将近 1/3 的项目失败或者陷入困境时因为需求原因导致的!垃圾进垃圾出(Garbage in, garbage out)”

修复需求错误的问题的成本非常高

需求分析目的

客户会告诉我们他们的需求,但大部分情况都不会告诉你需求背后的问题。而需求分析的终极目的,就是要“挖掘客户的问题,实现客户价值”!

深入了解客户的问题,有助于你更好的实现需求。

一般来说,需求分析有三重境界,分为“记录员”“分析员”“引导员”三个级别

要想做好需求分析,要时刻抓住“客户的问题和价值”这个指导思想!

需求分析的方法

需求分析 518 方法

5:5W,即 When、Where、Who、What、Why

5W 作为一组,首先是它们都以 W 开头,但这不是最关键,最关键的在于这些是一个需求产生的环境,或者说上下文(英文 Context)。为什么我们要关注需求产生的环境?很简单:环境影响需求。

举个很简单的例子:同样是垃圾桶,放在巴西贫民窟的要求和放在纽约帝国大厦肯定不一样。

1:1H,即 How

参见: 用例方法

很多人常犯的一个错误是在需求分析阶段分析了需求如何实现,这样做是不正确的。需求分析阶段的 How不是指如何实现需求,而是指需求本身的流程,如何实现需求那是设计阶段的事情!

在前面进行 5W 分析的时候,我们没有什么具体的指导方法,分析时主要靠分析人员的经验、水平,而How 则不一样,进行 How 分析时有一套成熟的方法,这就是“用例方法”!

8:8C,即 8 个 Constraint,包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility

前面的 5W+1H 是属于功能属性,而 8C 是属于质量属性

用例方法

参见: 1:1H,即 How

“用例是用来描述需求的流程”,即:描述 5W1H 中的 How。

用例方法三段法(NEA 方法)

1) 正常处理(Normal):通过和客户沟通,分析需求的正常流程;

2) 异常处理(Exception):在正常处理流程的步骤上,分析每一步的各种异常情况和对应的处理;

“异常”是指流程的异常情况,而不包含系统本身的的异常。

3) 替代处理(Alternative):在正常处理流程的步骤上,分析每一步是否有其它替代方法,以及替代方法如何做;

用例的具体写法

【用例名称】

【场景】

场景即用例发生的环境,正好对应 5W 中的 3 个 W:Who、Where、When

【用例描述】

描述详细的用例内容,对应 5W 中的 What 和 How,即用户应该怎样做,以及每个步骤中的输出。但并不要求每个步骤都一定有输出,可以有也可以没有,也可以有多个。

【用例价值】

描述用例对应的客户价值,对应 5W 中的 Why。

【约束和限制】

即整个需求流程中相关的约束和限制条件,对应 518 方法中的 8C。

要画图么?

必须是有了需求和用例之后,才有用例图,说白了,用例图是用例的图形化描述,但是它并不能取代用例。

还有另外一个更重要的原因:用例是客户和公司关于产品的一个共同认识!一般情况下,市场人员和客户沟通交流,了解客户的需求,然后和客户一一确认,最后形成需求文档。在这个过程中,主要是客户和市场人员参与,而没有研发的人员参与。

功能

有了用例之后,提取功能可以说是一个水到渠成的事情,基本上只是一个文字工作,我们只需要将用例中那些需要系统完成的事情——更简单的说:是动词——提取出来,就成为了系统的功能。

用例图的陷阱

所谓用例图,可以简单的理解为系统用例的集合,而不是详细描述每个用例的具体步骤和流程。这也是前面我们提到的为什么是用“用例”来分析需求,而不是用“用例图”来分析需
求的原因。

SSD

“系统顺序图”,主要用于描述某个用例的某个分支场景下,外部参与者与系统的交互过程。简单来说:SSD 就是用例的可视化描述。

用例方法分析需求的时候,确实不需要图;但用例方法分析完成后得到的用例,我们可以使用 SSD 让用例更直观一些。

领域模型

领域模型定义如下:
领域模型是对领域内的概念类或现实世界中对象的可视化表示,又称概念模型、领域对象模型、分析对象模型。它专注于分析问题领域本身,发掘重要的业务领域概念,并建立业务领域概念之间的关系。

这个阶段真正开始面向对象的工作

领域建模三字经

找名词

从需求模型中找,具体来说就是从用例中找。

加属性

找出领域模型的名词后,接下来一个重要工作就是将这些名词相关的属性找出来,使其更加准确。但加属性和前面找名词有一点点差别:有的属性并没有在用例中明确给出,需要分析人员和设计人员额外添加,此时也是分析师的行业和领域经验起决定作用。

连关系

设计模型

经过领域模型的分析后,面向对象已经初具雏形,但领域类并不能指导我们进行编码工作,因为领域类只是从用例模型中提炼出来的反应业务领域的概念,而并不是真正意义上的软件类。

是从用例模型中提炼出来的反应业务领域的概念,而并不是真正意义上的软件类。

设计模型主要包含 2 部分内容:静态模型、动态模型

静态模型又可以称为“类模型”,主要关注系统的“静态”结构,描述了系统包含的类, 以及类的名称、职责、属性、方法,类与类之间的关系。

第一步(照猫画虎):领域类映射

领域模型中的“领域类”,是设计模型中“软件类”最好的来源。
我们设计最初的“软件类”,具有如下几个明显的优点:
1)软件类来自领域类,领域类来自用例,用例来自客户,这样一环扣一环,软件类的正确性得到了保证,不用担心拍脑袋带来的问题;
2)领域类到软件类的转换非常简单,不需要天才的创新,或者丰富的想象力,只要掌握基本的面向对象的知识就能完成,菜鸟也能做设计;
3)不需要参考其它系统,不用担心没有参照物时无法设计的问题;

【类筛选】

【名称映射】

【属性映射】

【提炼方法】

从用例模型找动词

【筛选】

【提炼】

【分配】

第二步(精雕细琢):应用设计原则和设计模式

【设计原则】SOLID

单一职责原则 

开放/封闭原则 

Liskov 替换原则

接口隔离原则

依赖反转原则

我们都可以依次使用设计原则进行判断,当发现不符合设计原则的设计时,就采取增加、删除、合并、拆分等手段,使我们的设计逐步改进,最终达到符合设计原则的目的。

设计模式

"四人帮"

计原则和设计模式并不是竞争关系,正好相反,它们是互补的关系。
设计原则和设计模式互补体现在:设计原则主要用于指导“类的定义”的设计,而设计模式主要用于指导“类的行为”的设计,更通俗一点的讲:设计原则是类的静态设计原则,设计模式是类的动态设计原则。
一般情况下,我们是采用“先设计原则,后设计模式”的方法来操作的。

第三步(照本宣科):拆分辅助类

拆分辅助类的主要目的是为了使我们的类在编码的时候能够满足一些框架或者规范的要求。比如说常见的MVC 模式,将一个业务拆分成 Control、Model、View 三个元素;

动态模型关注系统的“动态”行为,描述类本身的一些动作或者状态变化,以及类之间如何配合以完成最终的业务功能。

动态模型设计一般都是在类模型设计完成后才开始,因为动态模型设计的时候一般都需要用到类模型中的类。相对类模型来说,动态模型要相对简单一些,主要原因在于动态模型设计的时候没有什么设计原则和设计模式需要应用,只需要对照用例模型,根据用例模型的特点,选取一个合适的动态模型将其表述出来即可。

【状态模型】

状态模型主要用于描述对象的生命周期的状态变化。通过状态图,我们可以了解到对象有哪些状态,状态之间如何转换,转换的触发条件等。当我们发现一个对象的状态比较复杂的时候,就需要设计对象的状态模型。

【活动模型】

活动模型主要用于描述一个工作流程或者计算流程。其关注点是在完成某项工作的过程中,系统中的哪些对象承担了什么样的任务、做了什么处理,以及这些对象之间的先后交互关系。当我们发现一个处理流程比较复杂的时候,就需要设计流程的活动模型。

【序列模型】

序列模型主要用于描述对象按照时间顺序组织的消息交互过程,其关键特征是强调按照“时间顺序”来组织对象的交互,所以序列图有时又称为“时序图”或者“顺序图”。序列模型是我们最常用的动态模型,特别适合将用例模型或者 SSD 转换为系统的动态模型。

【协作模型】

协作模型主要用于描述按照对象之间的关联来组织的消息交互过程,其关键特征是强调“对象关系”来组织对象的交互。协作模型的作用和序列模型一样,只是强调的点不同,大部分的时候我们都是选择“序列模型”,因为序列模型的时间顺序很多时候和用例模型的步骤不谋而合。

面向对象设计并不是什么高深的技术,也不需要天才的创新,更不需要变魔法,而是有章可循的,只要我们按照一定的步骤,一步一个脚印,不断精益求精,就能够完成面向对象的设计。

实现模型

c++

java

面向对象技巧

设计原则

内聚和耦合

内聚指一个模块内部元素彼此结合的紧密程度

是否专注模块的职责,才是内聚性的充要条件

【内聚的分类】

【巧合内聚(Coincidental cohesion)】- 最差

实际存在，类似“Utils”这样的包

【逻辑内聚(Logical cohesion)】

【时序内聚】

【过程内聚(Procedural cohesion)】

【交互内聚(Communicational cohesion)】

【顺序内聚(Sequential cohesion)】

【功能内聚(Functional cohesion)】

耦合(或者称依赖)是程序模块相互之间的依赖程度。

【耦合的分类】

【无耦合(No coupling)】

【消息耦合(Message coupling (low))】

【数据耦合(Data coupling)】

【数据结构耦合( Data-structured coupling)】

【控制耦合(Control coupling)】

【外部耦合(External coupling)】

【全局耦合(Globaling coupling)】

【内容耦合(Content coupling)】- 最差

高内聚低耦合

无论是“低内聚”,还是“高耦合”,其本质都是“不稳定”,不稳定就会带来工作量,带来风险,这当然不是我们希望看到的,所以我们应该做到“高内聚低耦合”。

类设计原则-SOLID

SRP,single responsibility principle,中文翻译为“单一职责原则”!

SRP 可以翻译成“一个类只负责一组相关的事情”

用于类的设计

OCP,Open-Closed Principle,中文翻译为“开闭原则”。

完整的 OCP 原则实际上应该这样表述:翻译一下就是:对使用者修改关闭,对提供者扩展开放!

总的指导思想

LSP,Liskov substitution principle,中文翻译为“里氏替换原则”

1) 子类必须实现或者继承父类所有的公有函数,否则调用者调用了一个父类中有的函数,而子类中没有,运行时就会出错;

2) 子类每个函数的输入参数必须和父类一样,否则调用父类的代码不能调用子类;

3) 子类每个函数的输出(返回值、修改全局变量、插入数据库、发送网络数据等)必须不比父类少,否则基于父类的输出做的处理就没法完成。

用于指导类继承的设计

ISP,Interface Segregation Principle,中文翻译为“接口隔离原则”

客户端不应该被强迫去依赖它们并不需要的接口。
ISP 原则承认对象需要非内聚的接口,然而 ISP 原则建议客户端不需要知道整个类,只需要知道具有内聚接口的抽象父类即可。

例子, 一体机，我们并不会设计一个“一体机”的接口,而是设计 N 个接口。

用于指导接口的设计

DIP,dependency inversion principle,中文翻译为“依赖倒置原则”

1) 高层模块不应该直接依赖低层模块,两者都应该依赖抽象层;
2) 抽象不能依赖细节,细节必须依赖抽象;

用于指导如何抽象

NOP,No Overdisgn Priciple,不要过度设计原则。

过犹不及

面向对象的初衷虽然是为了拥抱变化,但这个变化也是有一个度的,而不是预测得越长越好,原因很简单:预测越长,预测的结果正确性越低!

设计模式

【定义】

GoF 在《设计模式》一书中借用了 Christopher Alexander 对设计模式的定义:
“模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心”,即:模式是重复发生的问题的解决方案。

设计模式只是一把锤子，不是全能的“瑞士军刀”

《设计模式》的副标题是:可复用面向对象软件的基础!

1)设计模式解决的是“可复用”的设计问题;

2)设计模式应用的领域是“面向对象”;

23 个设计模式只是告诉了我们 how,而设计模式之道却可以告诉我们 why 和 where! 得不停的悟道。

设计模式之道： 对变化的概念进行封装(encapsulate the concept that varies)； Find what varies and encapsulate it, 翻译一下即“找到变化,封装变化”

“一个中心,两个基本点”

“找到变化,封装变化”的设计模式之道,加上 GoF 给出的“基于接口编程,而不是基于实现编程”  “优先使用对象组合而不是类继承”两个设计原则,组成了《设计模式》一书中 23 个设计模式的指导思想, 我称之为设计模式的“一个中心,两个基本点”,紧紧抓住这个指导思想,理解起来 23 个设计模式就容易多了。

模式详解

在实际应用的时候,我们不要一开始就想着要把某个模式塞到某个地方,而是先找到可能变化的地方,再来看具体使用哪个模式可以封装这种变化。

DECORATOR 模式

FACADE 模式

OBSERVER 模式

PROTOTYPE 模式

其他

UML

UML,Unified Modeling Language,中文翻译为“统一建模语言”。 目前已经基本上成为了事实上的工业标准。

最常见的误解是:掌握 UML,就掌握了设计;设计就是画 UML 图!

UML != 设计， just a langue，a tool.

UML 最大的作用在于“统一”；都用一样的语言来表述就简单方便了。

UML 应用

需求分析阶段

用例图

用例图架起了一座从客户需求过渡到软件开发的桥梁

直观的描述系统对外提供的功能

用例之间的关系

1)泛化

2)包含

3)扩展

4)依赖

设计阶段

类图

类图主要包含两部分:类定义和类关系

接口

接口可以认为是一个特殊的类,这个类只有抽象方法,没有属性。

类关系图

继承

实现

关联

关联:association,中文还有另外一个翻译:“与 。。。
。。。的交往”,而我认为拿这个翻译来理解“关联”是再合适不过了。

关联不等于关系。 UML 中类的关系有如下几种:继承/实现、依赖关系、组合关系、聚合关系,关联关系。

依赖

依赖是比关联更强的一种关系,一个类“依赖”了另外一个类,就意味着一旦被依赖的类发生改变,则依赖类也必须跟着改变。

方法调用

数据依赖

对象依赖

组合 && 聚合

相比依赖关系,聚合(aggregation)和组合(composition)又是更强的一种关系。依赖关系可以形象的描述为“没有你,我寸步难行”,而聚合和组合则可以形象的描述为“没有你,我将不存在”。

聚合:是一种“has a”的关系,即:某个类包含另外一个类,但并不负责另外类的维护,且两个类的对象生命周期是不一样的,“整体”销毁后,“部分”还能继续存在。

组合:是一种“owns a”的关系,即:某个类包含另外一个类,且还要负责另外类的维护,且两个类的对象生命周期是一样的,“整体”销毁后,“部分”同样被销毁了。

动态图

状态图

状态图主要用于描述一个对象的生命周期内的状态变化。

状态图:关注单个对象或者业务的“状态变化”

活动图

活动图主要用于描述一个工作流程或者计算流程。其关注点是在完成某项工作的过程中,系统中的哪些对象承担了什么样的任务、做了什么处理,以及这些对象之间的先后交互关系。

活动图:关注某个业务或者功能的“实现流程”

交互图

序列图

其关键特征是强调按照“时间顺序”来组织对象的交互

协作图

结构图

 组件图

部署阶段

部署图

部署图描述的是系统运行时的物理结构,展示了硬件的配置、硬件之间的关系
